package com.bluepdf.blue_pdf

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.pdf.PdfDocument
import android.graphics.pdf.PdfRenderer // ADDED FOR MERGING
import android.os.ParcelFileDescriptor // ADDED FOR MERGING
import androidx.annotation.NonNull
import io.flutter.embedding.android.FlutterActivity
import io.flutter.embedding.engine.FlutterEngine
import io.flutter.plugin.common.MethodChannel
import kotlinx.coroutines.*
import java.io.File
import java.io.FileOutputStream

class MainActivity : FlutterActivity() {
    private val CHANNEL = "bluepdf.native/Pdf_utility"

    override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
        super.configureFlutterEngine(flutterEngine)

        MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler { call, result ->
            // CORRECTED: Use a 'when' block to handle multiple methods
            when (call.method) {
                "generatePdfFromImages" -> {
                    val paths = call.argument<List<String>>("paths")
                    if (paths != null) {
                        CoroutineScope(Dispatchers.Default).launch {
                            try {
                                val pdfPath = generateCompressedPdfParallel(paths)
                                withContext(Dispatchers.Main) {
                                    result.success(pdfPath)
                                }
                            } catch (e: Exception) {
                                withContext(Dispatchers.Main) {
                                    result.error("PDF_ERROR", e.message, null)
                                }
                            }
                        }
                    } else {
                        result.error("NO_PATHS", "No image paths provided", null)
                    }
                }
                // ADDED: New case for handling PDF merging
                "mergePdfs" -> {
                    val paths = call.argument<List<String>>("paths")
                    if (paths != null) {
                        CoroutineScope(Dispatchers.IO).launch { // Use IO for heavy file operations
                            try {
                                val mergedPdfPath = mergePdfsNative(paths)
                                withContext(Dispatchers.Main) {
                                    result.success(mergedPdfPath)
                                }
                            } catch (e: Exception) {
                                withContext(Dispatchers.Main) {
                                    result.error("MERGE_ERROR", "Failed to merge PDFs: ${e.message}", null)
                                }
                            }
                        }
                    } else {
                        result.error("NO_PATHS", "No PDF paths provided for merging", null)
                    }
                }
                else -> result.notImplemented()
            }
        }
    }

    // --- UNCHANGED IMAGE-TO-PDF LOGIC ---
    private fun calculateInSampleSize(options: BitmapFactory.Options, reqWidth: Int, reqHeight: Int): Int {
        val (height: Int, width: Int) = options.run { outHeight to outWidth }
        var inSampleSize = 1
        if (height > reqHeight || width > reqWidth) {
            val halfHeight: Int = height / 2
            val halfWidth: Int = width / 2
            while (halfHeight / inSampleSize >= reqHeight && halfWidth / inSampleSize >= reqWidth) {
                inSampleSize *= 2
            }
        }
        return inSampleSize
    }

    private suspend fun generateCompressedPdfParallel(paths: List<String>): String = withContext(Dispatchers.IO) {
        val document = PdfDocument()
        val targetWidth = 595

        val scaledBitmaps = paths.mapIndexed { index, path ->
            async(Dispatchers.Default) {
                val file = File(path)
                if (!file.exists()) return@async null

                val options = BitmapFactory.Options().apply { inJustDecodeBounds = true }
                BitmapFactory.decodeFile(path, options)

                val aspectRatio = options.outHeight.toFloat() / options.outWidth
                val targetHeight = (targetWidth * aspectRatio).toInt()

                val sampleOptions = BitmapFactory.Options().apply {
                    inSampleSize = calculateInSampleSize(options, targetWidth, targetHeight)
                    inPreferredConfig = Bitmap.Config.RGB_565
                }

                val bitmap = BitmapFactory.decodeFile(path, sampleOptions) ?: return@async null
                val scaled = Bitmap.createScaledBitmap(bitmap, targetWidth, targetHeight, false)
                if (bitmap != scaled) bitmap.recycle()

                Triple(index, scaled, targetHeight)
            }
        }.awaitAll().filterNotNull().sortedBy { it.first }

        for ((index, scaledBitmap, targetHeight) in scaledBitmaps) {
            val pageInfo = PdfDocument.PageInfo.Builder(targetWidth, targetHeight, index + 1).create()
            val page = document.startPage(pageInfo)
            page.canvas.drawBitmap(scaledBitmap, 0f, 0f, null)
            document.finishPage(page)
            scaledBitmap.recycle()
        }
        
        val cacheDir = context.cacheDir
        val outputFile = File(cacheDir, "temp_pdf_${System.currentTimeMillis()}.pdf")
        var fileOutputStream: FileOutputStream? = null
        
        try {
            fileOutputStream = FileOutputStream(outputFile)
            document.writeTo(fileOutputStream)
        } finally {
            document.close()
            fileOutputStream?.close()
        }
        
        return@withContext outputFile.absolutePath
    }
    // --- END OF UNCHANGED IMAGE-TO-PDF LOGIC ---


    // --- ADDED: NATIVE FUNCTION FOR MERGING PDFS ---
    private suspend fun mergePdfsNative(paths: List<String>): String = withContext(Dispatchers.IO) {
        val outputDocument = PdfDocument()

        for (path in paths) {
            val file = File(path)
            if (!file.exists()) continue

            ParcelFileDescriptor.open(file, ParcelFileDescriptor.MODE_READ_ONLY).use { fileDescriptor ->
                PdfRenderer(fileDescriptor).use { renderer ->
                    for (i in 0 until renderer.pageCount) {
                        renderer.openPage(i).use { page ->
                            val pageInfo = PdfDocument.PageInfo.Builder(page.width, page.height, outputDocument.pages.size + 1).create()
                            val newPage = outputDocument.startPage(pageInfo)
                            val bitmap = Bitmap.createBitmap(page.width, page.height, Bitmap.Config.ARGB_8888)
                            
                            page.render(bitmap, null, null, PdfRenderer.Page.RENDER_MODE_FOR_DISPLAY)
                            newPage.canvas.drawBitmap(bitmap, 0f, 0f, null)
                            outputDocument.finishPage(newPage)
                            bitmap.recycle()
                        }
                    }
                }
            }
        }

        val cacheDir = context.cacheDir
        val outputFile = File(cacheDir, "merged_pdf_${System.currentTimeMillis()}.pdf")

        FileOutputStream(outputFile).use { outputStream ->
            outputDocument.writeTo(outputStream)
        }
        outputDocument.close()

        return@withContext outputFile.absolutePath
    }
}